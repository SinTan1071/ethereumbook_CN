[[smart_contracts_chapter]]
== 智能合约

我们已经在<<intro>>中讲过，Ethereum有两种不同类型的账户：外部账户（EOA）和合约账户。EOAs是由软件控制的，比如一个钱包应用程序，它属于Ethereum网络之外。合同帐户由运行在Ethereum虚拟机(EVM)中的软件控制。这两种类型的帐户都是通过Ethereum地址标识的。在本节中，我们将讨论第二种类型，合约帐户，以及控制它们的软件:智能合约。

[[smart_contracts_definition]]
=== 什么是智能合约?

历史中，_智能合约_这个词描述过各种不同的物品。在20世纪90年代，密码学家尼克·萨布(Nick Szabo)创造了这个词，并将其定义为“以数字形式指定的一组承诺，包括双方履行其他承诺的协议。”从那时起，智能合同的概念就不断演变，尤其是在2009年比特币引入了去中心化的区块链概念之后。在本书中，定义“智能合约”这个术语，指的是在以太虚拟机的环境中运行的不可变的确定性的计算机程序，您可以把虚拟机看做是一种去中心化的全局计算机。

我们一起剖析一下本书中的定义:

计算机程序: 智能合约，很简单，指的就是计算机程序。合约这个词在这没有任何法律意思。
不可变的: 与传统的软件不同，智能合约一旦部署到网络中后，其代码就无法修改。只能通过部署一个新的实例去修改之前的智能合约。
确定性:  对于任何一个运行合约的人，在合约被调用的交易上下文中，以及合约被执行时的以太坊区块链状态，都是相同的。
虚拟机运行环境: 智能合约的运行环境非常有限。只能访问自己的状态、调用它的交易的上下文以及一些最近的区块的信息。
去中心化的全局计算机: 虚拟机虽然只是运行在单一节点上的一个实例，但是因为它的初始状态以及每次运行后的结果都是确定的，所以可以把它看做是单一的全局计算机。

[[smart_contract_lifecycle]]
=== 智能合约的生命周期

智能合约是用高级语言编写的，例如Solidity. 运行前，必须被编译成EVM（参考<<EVM>>）可执行的二进制代码。编译完成后，合约就可以通过一个指向特殊的合约地址的交易部署到Ethereum区块链网络中。合约是用Ethereum地址来标识的，这个地址是通过合约创建时的包含源地址以及nonce的交易生成的。你可以使用智能合约地址来给智能合约发送资金，或者调用智能合约的函数。

值得重视的是，智能合约只有当其被某个交易调用的时候才执行。Ethereum中的所有智能合约都是由EOA发起的交易来驱动执行的。合约也可以调用另一个合约，另一个合约也可以调用另一个合约.., 但是第一个合约的调用必须又EOA发起。合约永远不会“自己执行”或者“运行在后台”。合约在区块链上实际上处于“休眠”的状态，直到有一个交易触发它。

不论一个交易调用多少合约，以及调用这些合约做什么，它都是_原子的_。只有交易成功的执行终止，才会在全局状态（合约、账户等）中记录所有的更改。这里成功终止指的是交易中调用的合约全部执行完毕而且没有错误。如果一个交易出错了，那么所有的影响将会“回滚”到没有执行它之前的状态。出错的交易任然保存在区块链上并且扣掉源账户使用的gas，但是对于合约以及账户的状态不会有任何影响。

合约的代码不可以被修改，但是可以“删除”，这里“删除”指的是从区块链中移除代码以及内部状态（变量）。要删除合约，只需要运行一个EVM中叫做 +SELFDESTRUCT+ （之前叫 +SUICIDE+ ）的操作吗。这个操作会花费“负gas”来触发改变全局状态，删除操作并不会删除合约的历史交易数据，因为区块链本身是不可修改的，因此只会在之后的区块中删除合约的状态。

[[high_level_languages]]
=== Ethereum 高级语言介绍

EVM是一个运行名为 _EVM bytecode_ 特殊形式机器码的仿真机，就像您的计算机CPU一样，只不过CPU中运行的是X86_64之类的机器码。我们将在<<EVM>>一章中详细介绍EVM的操作和语言。本节中，我们将研究如何编写在EVM上运行的智能合约。

虽然也可以通过直接编写EVM bytecode来编写智能合约，但是EVM的字节码非常笨拙而且难以阅读和理解，因此Ethereum开发人员都使用高级语言来编写，然后使用编译器将其转换为字节码。

尽管任何高级语言都可以编写智能合约，但这是一项非常繁的工作。因为智能合约是运行在一个资源高度受限并且极其简单的执行环境（EVM）中，在这个环境中，无法构建任何的用户界面、操作系统界面或者硬件界面。因此从头构建一种最小化的智能合约语言比约束通用语言使其适合编写智能合约要简单的多。正因如此，出现了很多专门编写智能合约的语言。Ethereum提供了几种这样的语言以及它们对应的编译器。

通常编程语言可以被分为两大类：声明式和命令式，或者叫做“函数式编程”和“过程式编程”。在声明式编程中，我们编写的函数表示程序的 _logic_ ，而不是它的  _flow_ ，创建的是没有 _side effects_ 的程序，这意味着函数之外的状态不会改变。声明式编程语言包括Haskell、SQL和HTML。相反，命令式编程中，程序员将逻辑和流程混在一起，这种语言包括BASIC、C、C++和JAVA等。另外有些语言和“混合”模式的，它们既可以用来进行声明式编程，同时也支持命令编程范式。这种混合模式的语言包括Lisp、Erlang、Prolog、JavaScript和Python。一般来讲，任何命令语言都可以用声明式范式进行编程，但会导致不优雅的代码。相比之下，纯声明式语言并不能用于编写命令式程序，因为在这种语言中，没有“变量”。

命令式编程更容易编写和读取数据，程序员也经常使用，但是要想编写出完全符合预期的程序却非常困难。程序的任何部分都可以修改程序的状态，因此很难知道程序下一步执行的结果，编写这种语言的程序很容易引出错误或者异常。相比之下，声明式编程虽然难以编写，但是没有这种副作用，程序员更容易理解程序的行为。

智能合约的编写对于程序员来说代价很高：因为修复bug需要花钱。因此，在编写不会产生意外的智能合约至关重要。因此，声明式语言在智能合约中所起的作用比在通用软件中的大得多。然而，你会看到为什么Solidity成为智能合约最高产的语言。

智能合约相关的语言排序（按年代先后顺序）：

LLL:: 一种功能(声明性的)编程语言，具有类似lisp的语法。这是Ethereum采用的第一个高级语言，但在今天很少使用。

Serpent:: 一种程序化(命令式)编程语言，其语法类似于Python。也可以用于编写函数(声明性)代码，尽管它并非完全没有副作用。首先由维塔利克·布特林创造。

Solidity:: 一种程序化(命令式)编程语言，其语法类似于JavaScript、c++或Java。Ethereum智能合约最流行、最常用的语言。作者是Gavin Wood(这本书的合著者)。

Vyper:: 一种最近开发的语言，类似于Serpent或者python的语法。想要比Python更接近一种纯粹的Serpent语言，但不是为了取代Python。首先由维塔利克·布特林创造。

Bamboo:: 一种新开发的语言，受Erlang的影响，具有显式的状态转换和没有迭代流(循环)。旨在减少副作用和增加可听性。非常新颖，很少使用。

正如您看到的，有许多语言可供选择。然而到目前为止，Solidity是最受欢迎的，因为它是以太坊事实上的官方语言，甚至一些其他的基于EVM的区块链也使用它。我们将花费大部分时间使用solid，但也将探索其他高级语言中的一些示例，以了解它们的不同哲学。


