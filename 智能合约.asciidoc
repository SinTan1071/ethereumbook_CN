[[smart_contracts_chapter]]
== 智能合约

我们已经在<<intro>>中讲过，Ethereum有两种不同类型的账户：外部账户（EOA）和合约账户。EOAs是由软件控制的，比如一个钱包应用程序，它属于Ethereum网络之外。合同帐户由运行在Ethereum虚拟机(EVM)中的软件控制。这两种类型的帐户都是通过Ethereum地址标识的。在本节中，我们将讨论第二种类型，合约帐户，以及控制它们的软件:智能合约。

[[smart_contracts_definition]]
=== 什么是智能合约?

历史中，_智能合约_这个词描述过各种不同的物品。在20世纪90年代，密码学家尼克·萨布(Nick Szabo)创造了这个词，并将其定义为“以数字形式指定的一组承诺，包括双方履行其他承诺的协议。”从那时起，智能合同的概念就不断演变，尤其是在2009年比特币引入了去中心化的区块链概念之后。在本书中，定义“智能合约”这个术语，指的是在以太虚拟机的环境中运行的不可变的确定性的计算机程序，您可以把虚拟机看做是一种去中心化的全局计算机。

我们一起剖析一下本书中的定义:

计算机程序: 智能合约，很简单，指的就是计算机程序。合约这个词在这没有任何法律意思。
不可变的: 与传统的软件不同，智能合约一旦部署到网络中后，其代码就无法修改。只能通过部署一个新的实例去修改之前的智能合约。
确定性:  对于任何一个运行合约的人，在合约被调用的交易上下文中，以及合约被执行时的以太坊区块链状态，都是相同的。
虚拟机运行环境: 智能合约的运行环境非常有限。只能访问自己的状态、调用它的交易的上下文以及一些最近的区块的信息。
去中心化的全局计算机: 虚拟机虽然只是运行在单一节点上的一个实例，但是因为它的初始状态以及每次运行后的结果都是确定的，所以可以把它看做是单一的全局计算机。

[[smart_contract_lifecycle]]
=== 智能合约的生命周期

智能合约是用高级语言编写的，例如Solidity. 运行前，必须被编译成EVM（参考<<EVM>>）可执行的二进制代码。编译完成后，合约就可以通过一个指向特殊的合约地址的交易部署到Ethereum区块链网络中。合约是用Ethereum地址来标识的，这个地址是通过合约创建时的包含源地址以及nonce的交易生成的。你可以使用智能合约地址来给智能合约发送资金，或者调用智能合约的函数。

值得重视的是，智能合约只有当其被某个交易调用的时候才执行。Ethereum中的所有智能合约都是由EOA发起的交易来驱动执行的。合约也可以调用另一个合约，另一个合约也可以调用另一个合约.., 但是第一个合约的调用必须又EOA发起。合约永远不会“自己执行”或者“运行在后台”。合约在区块链上实际上处于“休眠”的状态，直到有一个交易触发它。

不论一个交易调用多少合约，以及调用这些合约做什么，它都是_原子的_。只有交易成功的执行终止，才会在全局状态（合约、账户等）中记录所有的更改。这里成功终止指的是交易中调用的合约全部执行完毕而且没有错误。如果一个交易出错了，那么所有的影响将会“回滚”到没有执行它之前的状态。出错的交易任然保存在区块链上并且扣掉源账户使用的gas，但是对于合约以及账户的状态不会有任何影响。

合约的代码不可以被修改，但是可以“删除”，这里“删除”指的是从区块链中移除代码以及内部状态（变量）。要删除合约，只需要运行一个EVM中叫做 +SELFDESTRUCT+ （之前叫 +SUICIDE+ ）的操作吗。这个操作会花费“负gas”来触发改变全局状态，删除操作并不会删除合约的历史交易数据，因为区块链本身是不可修改的，因此只会在之后的区块中删除合约的状态。

[[high_level_languages]]
=== Ethereum 高级语言介绍

EVM是一个运行名为 _EVM bytecode_ 特殊形式机器码的仿真机，就像您的计算机CPU一样，只不过CPU中运行的是X86_64之类的机器码。我们将在<<EVM>>一章中详细介绍EVM的操作和语言。本节中，我们将研究如何编写在EVM上运行的智能合约。

虽然也可以通过直接编写EVM bytecode来编写智能合约，但是EVM的字节码非常笨拙而且难以阅读和理解，因此Ethereum开发人员都使用高级语言来编写，然后使用编译器将其转换为字节码。

尽管任何高级语言都可以编写智能合约，但这是一项非常繁的工作。因为智能合约是运行在一个资源高度受限并且极其简单的执行环境（EVM）中，在这个环境中，无法构建任何的用户界面、操作系统界面或者硬件界面。因此从头构建一种最小化的智能合约语言比约束通用语言使其适合编写智能合约要简单的多。正因如此，出现了很多专门编写智能合约的语言。Ethereum提供了几种这样的语言以及它们对应的编译器。



